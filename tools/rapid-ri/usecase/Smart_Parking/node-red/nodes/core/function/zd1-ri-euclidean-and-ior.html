<script type="text/html" data-template-name="euclidean and ior">
    <style>
        .func-tabs-row {
            margin-bottom: 0;
        }
        #node-input-libs-container-row .red-ui-editableList-container {
            padding: 0px;
        }
        #node-input-libs-container-row .red-ui-editableList-container li {
            padding:0px;
        }
        #node-input-libs-container-row .red-ui-editableList-item-remove {
            right: 5px;
        }

        #node-input-libs-container-row .red-ui-editableList-header {
            display: flex;
            background: var(--red-ui-tertiary-background);
            padding-right: 75px;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
        }
        #node-input-libs-container-row .red-ui-editableList-header > div {
            flex-grow: 1;
        }

        .node-libs-entry {
            display: flex;
        }

        .node-libs-entry .red-ui-typedInput-container {
            border-radius: 0;
            border: none;
        }
        .node-libs-entry .red-ui-typedInput-type-select {
            border-radius: 0 !important;
            height: 34px;
        }
        .node-libs-entry > span > input[type=text] {
            border-radius: 0;
            border-top-color: var(--red-ui-form-background);
            border-bottom-color: var(--red-ui-form-background);
            border-right-color: var(--red-ui-form-background);
        }
        .node-libs-entry > span > input[type=text].input-error {
        }
        .node-libs-entry > span {
            flex-grow: 1;
            width: 50%;
            position: relative;
        }
        .node-libs-entry span .node-input-libs-var, .node-libs-entry span .red-ui-typedInput-container {
            width: 100%;
        }
        .node-libs-entry > span > span > i {
            display: none;
        }
        .node-libs-entry > span > span.input-error > i {
            display: inline;
        }

    </style>
    <input type="hidden" id="node-input-func">
    <input type="hidden" id="node-input-noerr">
    <input type="hidden" id="node-input-finalize">
    <input type="hidden" id="node-input-initialize">

    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="common.label.name"></span></label>
        <div style="display: inline-block; width: calc(100% - 105px)"><input type="text" id="node-input-name" data-i18n="[placeholder]common.label.name"></div>
    </div>


    <div class="form-row func-tabs-row">
        <ul style="min-width: 600px; margin-bottom: 20px;" id="func-tabs"></ul>
    </div>
    <div id="func-tabs-content" style="min-height: calc(100% - 95px);">

        <div id="func-tab-config" style="display:none">
            <div>
                <div class="form-row" style="display: inline-block; margin-right: 50px;">
                    <label for="node-input-outputs"><i class="fa fa-random"></i> <span data-i18n="function.label.outputs"></span></label>
                    <input id="node-input-outputs" style="width: 60px;" value="1">
                </div>
                <div class="form-row" style="display: inline-block;">
                    <label for="node-input-timeout"><i class="fa fa-clock-o"></i> <span data-i18n="function.label.timeout"></span></label>
                    <input id="node-input-timeout" style="width: 60px;" data-i18n="[placeholder]join.seconds">
                </div>
            </div>

            <div class="form-row node-input-libs-row hide" style="margin-bottom: 0px;">
                <label><i class="fa fa-cubes"></i> <span data-i18n="function.label.modules"></span></label>
            </div>
            <div class="form-row node-input-libs-row hide" id="node-input-libs-container-row">
                <ol id="node-input-libs-container"></ol>
            </div>
        </div>

        <div id="func-tab-init" style="display:none">
            <div class="form-row node-text-editor-row" style="position:relative">
                <div style="height: 250px; min-height:150px;" class="node-text-editor" id="node-input-init-editor" ></div>
                <div style="position: absolute; right:0; bottom: calc(100% - 20px); z-Index: 10;"><button type="button" id="node-init-expand-js" class="red-ui-button red-ui-button-small"><i class="fa fa-expand"></i></button></div>
            </div>
        </div>

        <div id="func-tab-body" style="display:none">
            <div class="form-row node-text-editor-row" style="position:relative">
                <div style="height: 220px; min-height:150px;" class="node-text-editor" id="node-input-func-editor" ></div>
                <div style="position: absolute; right:0; bottom: calc(100% - 20px); z-Index: 10;"><button type="button" id="node-function-expand-js" class="red-ui-button red-ui-button-small"><i class="fa fa-expand"></i></button></div>
            </div>
        </div>

        <div id="func-tab-finalize" style="display:none">
            <div class="form-row node-text-editor-row" style="position:relative">
                <div style="height: 250px; min-height:150px;" class="node-text-editor" id="node-input-finalize-editor" ></div>
                <div style="position: absolute; right:0; bottom: calc(100% - 20px); z-Index: 10;"><button type="button" id="node-finalize-expand-js" class="red-ui-button red-ui-button-small"><i class="fa fa-expand"></i></button></div>
            </div>
        </div>

    </div>
</script>

<script type="text/javascript">

(function() {

    var invalidModuleVNames = [
        'console',
        'util',
        'Buffer',
        'Date',
        'RED',
        'node',
        '__node__',
        'context',
        'flow',
        'global',
        'env',
        'setTimeout',
        'clearTimeout',
        'setInterval',
        'clearInterval',
        'promisify'
    ]

    var knownFunctionNodes = {};
    RED.events.on("nodes:add", function(n) {
        if (n.type === "function") {
            knownFunctionNodes[n.id] = n;
        }
    })
    RED.events.on("nodes:remove", function(n) {
        if (n.type === "function") {
            delete knownFunctionNodes[n.id];
        }
    })

    var missingModules = [];
    var missingModuleReasons = {};
    RED.events.on("runtime-state", function(event) {
        if (event.error === "missing-modules") {
            missingModules = event.modules.map(function(m) { missingModuleReasons[m.module] = m.error; return m.module });
            for (var id in knownFunctionNodes) {
                if (knownFunctionNodes.hasOwnProperty(id) && knownFunctionNodes[id].libs && knownFunctionNodes[id].libs.length > 0) {
                    RED.editor.validateNode(knownFunctionNodes[id])
                }
            }
        } else if (!event.text) {
            missingModuleReasons = {};
            missingModules = [];
            for (var id in knownFunctionNodes) {
                if (knownFunctionNodes.hasOwnProperty(id) && knownFunctionNodes[id].libs && knownFunctionNodes[id].libs.length > 0) {
                    RED.editor.validateNode(knownFunctionNodes[id])
                }
            }
        }
        RED.view.redraw();
    });

    var installAllowList = ['*'];
    var installDenyList = [];

    var modulesEnabled = true;
    if (RED.settings.get('externalModules.modules.allowInstall', true) === false) {
        modulesEnabled = false;
    }
    var settingsAllowList = RED.settings.get("externalModules.modules.allowList")
    var settingsDenyList = RED.settings.get("externalModules.modules.denyList")
    if (settingsAllowList || settingsDenyList) {
        installAllowList = settingsAllowList;
        installDenyList = settingsDenyList
    }
    installAllowList = RED.utils.parseModuleList(installAllowList);
    installDenyList = RED.utils.parseModuleList(installDenyList);


    // object that maps from library name to its descriptor
    var allLibs = [];

    function moduleName(module) {
        var match = /^([^@]+)@(.+)/.exec(module);
        if (match) {
            return [match[1], match[2]];
        }
        return [module, undefined];
    }

    function getAllUsedModules() {
        var moduleSet = new Set();
        for (var id in knownFunctionNodes) {
            if (knownFunctionNodes.hasOwnProperty(id)) {
                if (knownFunctionNodes[id].libs) {
                    for (var i=0, l=knownFunctionNodes[id].libs.length; i<l; i++) {
                        if (RED.utils.checkModuleAllowed(knownFunctionNodes[id].libs[i].module,null,installAllowList,installDenyList)) {
                            moduleSet.add(knownFunctionNodes[id].libs[i].module);
                        }
                    }
                }
            }
        }
        var modules = Array.from(moduleSet);
        modules.sort();
        return modules;
    }

    function prepareLibraryConfig(node) {
        $(".node-input-libs-row").show();
        var usedModules = getAllUsedModules();
        var typedModules = usedModules.map(function(l) {
            return {icon:"fa fa-cube", value:l,label:l,hasValue:false}
        })
        typedModules.push({
            value:"_custom_", label:RED._("editor:subflow.licenseOther"), icon:"red/images/typedInput/az.svg"
        })

        var libList = $("#node-input-libs-container").css('min-height','100px').css('min-width','450px').editableList({
            header: $('<div><div data-i18n="node-red:function.require.moduleName"></div><div data-i18n="node-red:function.require.importAs"></div></div>'),
            addItem: function(container,i,opt) {
                var parent = container.parent();
                var row0 = $("<div/>").addClass("node-libs-entry").appendTo(container);
                var fmoduleSpan = $("<span>").appendTo(row0);
                var fmodule = $("<input/>", {
                    class: "node-input-libs-val",
                    placeholder: RED._("node-red:function.require.module"),
                    type: "text"
                }).css({
                }).appendTo(fmoduleSpan).typedInput({
                    types: typedModules,
                    default: usedModules.indexOf(opt.module) > -1 ? opt.module : "_custom_"
                });
                if (usedModules.indexOf(opt.module) === -1) {
                    fmodule.typedInput('value', opt.module);
                }
                var moduleWarning = $('<span style="position: absolute;right:2px;top:7px; display:inline-block; width: 16px;"><i class="fa fa-warning"></i></span>').appendTo(fmoduleSpan);
                RED.popover.tooltip(moduleWarning.find("i"),function() {
                    var val = fmodule.typedInput("type");
                    if (val === "_custom_") {
                        val = fmodule.val();
                    }
                    var errors = [];

                    if (!RED.utils.checkModuleAllowed(val,null,installAllowList,installDenyList)) {
                        return RED._("node-red:function.error.moduleNotAllowed",{module:val});
                    } else {
                        return RED._("node-red:function.error.moduleLoadError",{module:val,error:missingModuleReasons[val]});
                    }
                })

                var fvarSpan = $("<span>").appendTo(row0);

                var fvar = $("<input/>", {
                    class: "node-input-libs-var red-ui-font-code",
                    placeholder: RED._("node-red:function.require.var"),
                    type: "text"
                }).css({
                }).appendTo(fvarSpan).val(opt.var);
                var vnameWarning = $('<span style="position: absolute; right:2px;top:7px;display:inline-block; width: 16px;"><i class="fa fa-warning"></i></span>').appendTo(fvarSpan);
                RED.popover.tooltip(vnameWarning.find("i"),function() {
                    var val = fvar.val();
                    if (invalidModuleVNames.indexOf(val) !== -1) {
                        return RED._("node-red:function.error.moduleNameReserved",{name:val})
                    } else {
                        return RED._("node-red:function.error.moduleNameError",{name:val})
                    }
                })



                fvar.on("change keyup paste", function (e) {
                    var v = $(this).val().trim();
                    if (v === "" || / /.test(v) || invalidModuleVNames.indexOf(v) !== -1) {
                        fvar.addClass("input-error");
                        vnameWarning.addClass("input-error");
                    } else {
                        fvar.removeClass("input-error");
                        vnameWarning.removeClass("input-error");
                    }
                });

                fmodule.on("change keyup paste", function (e) {
                    var val = $(this).typedInput("type");
                    if (val === "_custom_") {
                        val = $(this).val();
                    }
                    var varName = val.trim().replace(/^@/,"").replace(/@.*$/,"").replace(/[-_/\.].?/g, function(v) { return v[1]?v[1].toUpperCase():"" });
                    fvar.val(varName);
                    fvar.trigger("change");

                    if (RED.utils.checkModuleAllowed(val,null,installAllowList,installDenyList) && (missingModules.indexOf(val) === -1)) {
                        fmodule.removeClass("input-error");
                        moduleWarning.removeClass("input-error");
                    } else {
                        fmodule.addClass("input-error");
                        moduleWarning.addClass("input-error");
                    }
                });
                if (RED.utils.checkModuleAllowed(opt.module,null,installAllowList,installDenyList) && (missingModules.indexOf(opt.module) === -1)) {
                    fmodule.removeClass("input-error");
                    moduleWarning.removeClass("input-error");
                } else {
                    fmodule.addClass("input-error");
                    moduleWarning.addClass("input-error");
                }
                if (opt.var) {
                    fvar.trigger("change");
                }
            },
            removable: true
        });

        var libs = node.libs || [];
        for (var i=0,l=libs.length;i<l; i++) {
            libList.editableList('addItem',libs[i])
        }

    }

    function getLibsList() {
        var _libs = [];
        if (RED.settings.functionExternalModules !== false) {
            var libs = $("#node-input-libs-container").editableList("items");
            libs.each(function(i) {
                var item = $(this);
                var v = item.find(".node-input-libs-var").val();
                var n = item.find(".node-input-libs-val").typedInput("type");
                if (n === "_custom_") {
                    n = item.find(".node-input-libs-val").val();
                }
                if ((!v || (v === "")) ||
                    (!n || (n === ""))) {
                    return;
                }
                _libs.push({
                    var: v,
                    module: n
                });
            });
        }
        return _libs;
    }

    RED.nodes.registerType('euclidean and ior',{
        color:"#FFA500",
        category: 'rapid ri',
        defaults: {
            name: {value:"_DEFAULT_"},
            func: {value:"let region_name = \"predefined_regions_1\";\nlet detection_name = \"object_detection_1\";\nlet previous_data_name = \"previous_data_1\";\nlet occupancy_check_duration = 60;\nlet video_id = 1;\nlet region_id = -1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\nvar stop_duration = flow.get(\"stop_duration\");\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty(\"type\")) {\n            current_object_data[\"type\"] = object_data[\"type\"];\n        }\n        if (object_data.hasOwnProperty(\"color\")) {\n            current_object_data[\"color\"] = object_data[\"color\"];\n        }\n        if (object_data.hasOwnProperty(\"license_plate\")) {\n            current_object_data[\"license_plate\"] = object_data[\"license_plate\"];\n        }\n        if (object_data.hasOwnProperty(\"id\")) {\n            current_object_data[\"id\"] = object_data[\"id\"];\n        }\n        if (object_data.hasOwnProperty(\"roi_type\")) {\n            current_object_data[\"roi_type\"] = object_data[\"roi_type\"];\n        }\n        return current_object_data;\n    }\n    function getLotBbox(lot_data) {\n        return { \"vertex1\": lot_data.vertex1, \"vertex2\": lot_data.vertex2, \"vertex3\": lot_data.vertex3, \"vertex4\": lot_data.vertex4, \"vertex_0\": lot_data.vertex1 };\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var objectData = getObjectData(payload[key]);\n            if (objectData !== null) {\n                objects_extra.push(\n                    objectData\n                );\n                objects.push(\n                    payload[key][\"bbox\"]\n                );\n            }\n        }\n    }\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    function getBboxCentroid(bbox) {\n        var centroid_x = (bbox[\"vertex1\"].x + bbox[\"vertex2\"].x + bbox[\"vertex3\"].x + bbox[\"vertex4\"].x) / 4;\n        var centroid_y = (bbox[\"vertex1\"].y + bbox[\"vertex2\"].y + bbox[\"vertex3\"].y + bbox[\"vertex4\"].y) / 4;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIntersectArea(bbox1, bbox2) { // objects, lots\n        var bbox1_key = Object.keys(bbox1)\n        var bbox2_key = Object.keys(bbox2)\n        var intersection = [];\n\n        for (let i = 0; i < bbox1_key.length - 1; i++) {\n            for (let j = 0; j < bbox2_key.length - 1; j++) {\n                var A1 = bbox1[bbox1_key[i + 1]].y - bbox1[bbox1_key[i]].y; // Ax + By + C = 0\n                var B1 = bbox1[bbox1_key[i]].x - bbox1[bbox1_key[i + 1]].x;\n                var C1 = - A1 * bbox1[bbox1_key[i]].x - B1 * bbox1[bbox1_key[i]].y;\n\n                var A2 = bbox2[bbox2_key[j + 1]].y - bbox2[bbox2_key[j]].y;\n                var B2 = bbox2[bbox2_key[j]].x - bbox2[bbox2_key[j + 1]].x;\n                var C2 = - A2 * bbox2[bbox2_key[j]].x - B2 * bbox2[bbox2_key[j]].y;\n\n                // parallel lines case\n                if (A1 * B2 == A2 * B1) {\n                    // coincide case\n                    if ((A1 * C2 == A2 * C1) && (B1 * C2 == B2 * C1)) {\n                        if (B1 == 0 && A1 == 0) { // one point bbox case\n                            intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B2 == 0 && A2 == 0) { // one point bbox case\n                            intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                        }\n                        else if (B1 == 0) { // vertical lines case\n                            var y_min1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i]].y : bbox1[bbox1_key[i + 1]].y;\n                            var y_max1 = (bbox1[bbox1_key[i]].y < bbox1[bbox1_key[i + 1]].y) ? bbox1[bbox1_key[i + 1]].y : bbox1[bbox1_key[i]].y;\n                            var y_min2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i]].y : bbox2[bbox2_key[i + 1]].y;\n                            var y_max2 = (bbox2[bbox2_key[i]].y < bbox2[bbox2_key[i + 1]].y) ? bbox2[bbox2_key[i + 1]].y : bbox2[bbox2_key[i]].y;\n                            if ((y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var y_min = (y_min1 < y_min2) ? y_min2 : y_min1;\n                                var y_max = (y_max1 < y_max2) ? y_max1 : y_max2;\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_min.toFixed(6)]);\n                                intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), y_max.toFixed(6)]);\n                            }\n                        }\n                        else if (A1 == 0) { // horizontal lines case\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                intersection.push([x_min.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                            }\n                        }\n                        else {\n                            var x_min1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i]].x : bbox1[bbox1_key[i + 1]].x;\n                            var x_max1 = (bbox1[bbox1_key[i]].x < bbox1[bbox1_key[i + 1]].x) ? bbox1[bbox1_key[i + 1]].x : bbox1[bbox1_key[i]].x;\n                            var x_min2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i]].x : bbox2[bbox2_key[i + 1]].x;\n                            var x_max2 = (bbox2[bbox2_key[i]].x < bbox2[bbox2_key[i + 1]].x) ? bbox2[bbox2_key[i + 1]].x : bbox2[bbox2_key[i]].x;\n                            if ((x_min1 < x_max2) && (x_min2 < x_max1) && (y_min1 < y_max2) && (y_min2 < y_max1)) {\n                                var x_min = (x_min1 < x_min2) ? x_min2 : x_min1;\n                                var x_max = (x_max1 < x_max2) ? x_max1 : x_max2;\n                                var xY_min = (-A1 * x_min - C1) / B1\n                                var xY_max = (-A1 * x_max - C1) / B1\n                                intersection.push([x_min.toFixed(6), xY_min.toFixed(6)]);\n                                intersection.push([x_max.toFixed(6), xY_max.toFixed(6)]);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // get intersection coordinates\n                    var x1 = bbox1[bbox1_key[i]].x;\n                    var x2 = bbox1[bbox1_key[i + 1]].x;\n                    var x3 = bbox2[bbox2_key[j]].x;\n                    var x4 = bbox2[bbox2_key[j + 1]].x;\n                    var y1 = bbox1[bbox1_key[i]].y;\n                    var y2 = bbox1[bbox1_key[i + 1]].y;\n                    var y3 = bbox2[bbox2_key[j]].y;\n                    var y4 = bbox2[bbox2_key[j + 1]].y;\n\n                    var den = (x2 - x1) * (y3 - y4) - (y2 - y1) * (x3 - x4);\n                    var t = ((x3 - x1) * (y3 - y4) - (y3 - y1) * (x3 - x4)) / den;\n                    var u = ((x3 - x1) * (y1 - y2) - (y3 - y1) * (x1 - x2)) / den;\n                    if ((t >= 0) && (t <= 1) && (u >= 0) && (u <= 1)) { // intersect happens if this condition is fulfilled\n                        var ix = x1 + t * (x2 - x1);\n                        var iy = y1 + t * (y2 - y1);\n                        intersection.push([ix.toFixed(6), iy.toFixed(6)]);\n                    }\n                }\n            }\n        }\n        // get clipped coordinates\n        var specialcase1 = true;\n        var specialcase2 = false;\n        var temp1 = bbox1[bbox1_key[0]];\n        var temp2 = bbox2[bbox2_key[0]];\n        for (let i = 1; i < bbox1_key.length - 1; i++) { // special case\n            if (temp1 !== bbox1[bbox1_key[i]]) {\n                specialcase1 = false;\n                break;\n            }\n        }\n        for (let i = 1; i < bbox2_key.length - 1; i++) {\n            if (temp2 !== bbox2[bbox2_key[i]]) {\n                specialcase2 = false;\n                break;\n            }\n        }\n        if (!(specialcase2)) {\n            for (let i = 0; i < bbox1_key.length - 1; i++) {\n                var sign_check = [];\n                for (let j = 0; j < bbox2_key.length - 1; j++) {\n                    var x1 = bbox2[bbox2_key[j]].x\n                    var x2 = bbox2[bbox2_key[j + 1]].x\n                    var y1 = bbox2[bbox2_key[j]].y\n                    var y2 = bbox2[bbox2_key[j + 1]].y\n                    var cross_prod = (bbox1[bbox1_key[i]].x - x1) * (y2 - y1) - (bbox1[bbox1_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) { // similar signs indicate the coordinate is within another bbox\n                    intersection.push([bbox1[bbox1_key[i]].x.toFixed(6), bbox1[bbox1_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox1[bbox1_key[i]].x, bbox1[bbox1_key[i]].y]);\n                }\n            }\n        }\n        if (!(specialcase1)) {\n            for (let i = 0; i < bbox2_key.length - 1; i++) { // similar purpose but for second bbox\n                var sign_check = [];\n                for (let j = 0; j < bbox1_key.length - 1; j++) {\n                    var x1 = bbox1[bbox1_key[j]].x\n                    var x2 = bbox1[bbox1_key[j + 1]].x\n                    var y1 = bbox1[bbox1_key[j]].y\n                    var y2 = bbox1[bbox1_key[j + 1]].y\n                    var cross_prod = (bbox2[bbox2_key[i]].x - x1) * (y2 - y1) - (bbox2[bbox2_key[i]].y - y1) * (x2 - x1);\n                    var sign = (cross_prod >= 0) ? true : false;\n                    sign_check.push(sign);\n                }\n                if (sign_check.length === 4 && (sign_check.every((val, index) => val === [true, true, true, true][index]) ||\n                    sign_check.every((val, index) => val === [false, false, false, false][index]))) {\n                    intersection.push([bbox2[bbox2_key[i]].x.toFixed(6), bbox2[bbox2_key[i]].y.toFixed(6)]);\n                    //intersection.push([bbox2[bbox2_key[i]].x, bbox2[bbox2_key[i]].y]);\n                }\n            }\n        }\n        intersection = intersection.filter((item, index, self) =>\n            index === self.findIndex((t) => JSON.stringify(t) === JSON.stringify(item))\n        );\n        // sort intersection points\n        if (intersection.length > 2) {\n            var intersection_angle = [];\n            var intersection_distance = [];\n\n            let minIndex = intersection.reduce((minIdx, currentValue, currentIndex, array) => {\n                if (currentValue[0] < array[minIdx][0]) {\n                    return currentIndex;\n                } else if (currentValue[0] === array[minIdx][0]) {\n                    return currentValue[1] < array[minIdx][1] ? currentIndex : minIdx;\n                } else {\n                    return minIdx;\n                }\n            }, 0);\n            var temp_intersection = intersection.filter((_, index) => index !== minIndex);\n            for (let i = 0; i < temp_intersection.length; i++) {\n                intersection_angle.push(Math.atan2(temp_intersection[i][1] - intersection[minIndex][1], temp_intersection[i][0] - intersection[minIndex][0]));\n                intersection_distance.push((temp_intersection[i][1] - intersection[minIndex][1]) ** 2 + (temp_intersection[i][0] - intersection[minIndex][0]) ** 2);\n            }\n            let combined = temp_intersection.map((point, index) => ({ // sort intersect coordinates based on angle and then distance\n                point: point,\n                angle: intersection_angle[index],\n                distance: intersection_distance[index]\n            }));\n            combined.sort((a, b) => a.angle - b.angle || a.distance - b.distance);\n            let sorted_intersection = combined.map(item => item.point);\n            sorted_intersection.unshift(intersection[minIndex]);\n            sorted_intersection.push(intersection[minIndex]);\n            // shoelace algorithm to calculate the intersect area\n            var area = 0;\n            for (let i = 0; i < sorted_intersection.length - 1; i++) {\n                area += ((sorted_intersection[i][0] * sorted_intersection[i + 1][1])\n                    - (sorted_intersection[i + 1][0] * sorted_intersection[i][1]))\n            }\n            return area;\n        }\n        return 0;\n    }\n    function calculateIOU(bbox1, bbox2, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area1 = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n\n            var lot_area2 = (bbox2[\"vertex1\"].x * bbox2[\"vertex2\"].y) + (bbox2[\"vertex2\"].x * bbox2[\"vertex3\"].y)\n                + (bbox2[\"vertex3\"].x * bbox2[\"vertex4\"].y) + (bbox2[\"vertex4\"].x * bbox2[\"vertex_0\"].y)\n                - ((bbox2[\"vertex2\"].x * bbox2[\"vertex1\"].y) + (bbox2[\"vertex3\"].x * bbox2[\"vertex2\"].y)\n                    + (bbox2[\"vertex4\"].x * bbox2[\"vertex3\"].y) + (bbox2[\"vertex_0\"].x * bbox2[\"vertex4\"].y));\n            return intersectArea / (lot_area1 + lot_area2 - intersectArea)\n        }\n        return 0;\n    }\n    function calculateIOR(bbox1, intersectArea) {\n        if (intersectArea !== 0) {\n            var lot_area = (bbox1[\"vertex1\"].x * bbox1[\"vertex2\"].y) + (bbox1[\"vertex2\"].x * bbox1[\"vertex3\"].y)\n                + (bbox1[\"vertex3\"].x * bbox1[\"vertex4\"].y) + (bbox1[\"vertex4\"].x * bbox1[\"vertex_0\"].y)\n                - ((bbox1[\"vertex2\"].x * bbox1[\"vertex1\"].y) + (bbox1[\"vertex3\"].x * bbox1[\"vertex2\"].y)\n                    + (bbox1[\"vertex4\"].x * bbox1[\"vertex3\"].y) + (bbox1[\"vertex_0\"].x * bbox1[\"vertex4\"].y));\n            return intersectArea / lot_area;\n        }\n        return 0;\n    }\n\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({ \"occupied\": 0 });\n        }\n    }\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) { // find all lots within the object centroid distance threshold\n            var objectCentroid = getBboxCentroid(payload[\"objects\"][key1]);\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getBboxCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // calculate IOU or IOR\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        var IOR = 0;\n                        if (intersection_type == \"region\") {\n                            IOR = calculateIOR(payload[\"lots\"][i], intersectRegion)\n                        }\n                        else if (intersection_type == \"object\") {\n                            IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                        }\n                        if (IOR > intersection_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            else { // consider the best lot only\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var intersectRegion = calculateIntersectArea(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    var IOR = 0;\n                    if (intersection_type == \"region\") {\n                        IOR = calculateIOR(payload[\"lots\"][best_region_index], intersectRegion)\n                    }\n                    else if (intersection_type == \"object\") {\n                        IOR = calculateIOR(payload[\"objects\"][key1], intersectRegion)\n                    }\n                    if (IOR > intersection_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied;\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        results = initializeResults(results, occupied, i);\n        previous_data = initializePreviousData(results, i);\n        if (results[\"Region \" + (i + 1)].hasOwnProperty(\"id\") || previous_data[\"Region \" + (i + 1)].hasOwnProperty(\"id\")) {\n            results = handleObjectWithID(results, i);\n        }\n        else if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            results = handleOccupiedRegion(results, i);\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results = handleNotOccupiedRegion(results, i);\n        }\n    }\n    return results;\n}\n\nfunction initializeResults(results, occupied, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    if (!results[regionKey]) {\n        results[regionKey] = {};\n    }\n    results[regionKey][\"video_id\"] = video_id;\n    results[regionKey][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n    if (occupied[i].hasOwnProperty(\"occupied\")) {\n        results[regionKey][\"occupied\"] = occupied[i].occupied;\n    }\n\n    if (occupied[i].hasOwnProperty(\"extra\")) {\n        for (let key in occupied[i].extra) {\n            results[regionKey][key] = occupied[i].extra[key];\n        }\n    }\n    if (results[regionKey].hasOwnProperty(\"id\") || (previous_data && previous_data.hasOwnProperty(regionKey) && previous_data[regionKey].hasOwnProperty(\"id\"))) {\n        results[regionKey][\"actual_entry_time\"] = [];\n        results[regionKey][\"actual_dwell_time\"] = [];\n        results[regionKey][\"entry_time\"] = [];\n        results[regionKey][\"dwell_time\"] = [];\n        results[regionKey][\"exit_time\"] = [];\n    }\n    else {\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"actual_dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"entry_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"exit_time\"] = \"\";\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n    }\n    return results;\n}\n\nfunction initializePreviousData(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    // Ensure previous_data is set up for this region.\n    if (!previous_data) {\n        previous_data = {};\n    }\n    if (results[regionKey].hasOwnProperty(\"id\")) {\n        if (!previous_data[regionKey]) {\n            previous_data[regionKey] = {};\n            previous_data[regionKey][\"id\"] = [];\n            previous_data[regionKey][\"actual_entry_time\"] = [];\n            previous_data[regionKey][\"actual_dwell_time\"] = [];\n            previous_data[regionKey][\"entry_time\"] = [];\n            previous_data[regionKey][\"dwell_time\"] = [];\n            previous_data[regionKey][\"exit_time\"] = [];\n        }\n    }\n    else {\n        if (!previous_data.hasOwnProperty(regionKey)) {\n            previous_data[regionKey] = results[regionKey];\n            previous_data[regionKey][\"actual_entry_time\"] = \"\";\n            previous_data[regionKey][\"actual_dwell_time\"] = \"\";\n            previous_data[regionKey][\"entry_time\"] = \"\";\n            previous_data[regionKey][\"dwell_time\"] = \"\";\n            previous_data[regionKey][\"exit_time\"] = \"\";\n            previous_data[regionKey][\"occupancy_check\"] = 0;\n        }\n    }\n\n    return previous_data;\n}\n\nfunction handleObjectWithID(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    const resultIds = results[regionKey][\"id\"];\n    const previousDataIds = previous_data[regionKey][\"id\"];\n\n    if (!resultIds && !previousDataIds) {\n        return results;\n    }\n\n    if (resultIds) {\n        for (let j = 0; j < resultIds.length; j++) {\n            // Check existing id data\n            let prevIndex = -1;\n\n            if (previous_data[regionKey][\"id\"] && previous_data[regionKey][\"id\"].length > 0) {\n                prevIndex = previous_data[regionKey][\"id\"].indexOf(resultIds[j]);\n            }\n\n            if (prevIndex === -1) {\n                results[regionKey][\"actual_entry_time\"].push(msg.nodered_timestamp);\n                results[regionKey][\"entry_time\"].push(msg.object_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(\"00:00:00\");\n                results[regionKey][\"dwell_time\"].push(0);\n                results[regionKey][\"exit_time\"].push(\"\");\n            } else {\n                results[regionKey][\"actual_entry_time\"].push(previous_data[regionKey][\"actual_entry_time\"][prevIndex]);\n                results[regionKey][\"entry_time\"].push(previous_data[regionKey][\"entry_time\"][prevIndex]);\n\n                // Calculate dwell time.\n                const dwell_timestamp = (msg.object_timestamp - results[regionKey][\"entry_time\"][j]);\n                const dwell_hours = Math.floor(dwell_timestamp / 3600).toString().padStart(2, \"0\");\n                const dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n                const dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n                results[regionKey][\"dwell_time\"].push(dwell_timestamp);\n                results[regionKey][\"actual_dwell_time\"].push(dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds);\n                results[regionKey][\"exit_time\"].push(\"\");\n            }\n        }\n    }\n\n    if (previousDataIds) {\n        for (let j = 0; j < previousDataIds.length; j++) {\n            let prevIndex = -1;\n\n            if (!results[regionKey][\"id\"]) {\n                results[regionKey] = previous_data[regionKey];\n                results[regionKey][\"occupied\"] = 0;\n                break;\n            }\n            else {\n                if (!results[regionKey][\"dwell_time\"].some(val => val >= stop_duration)) {\n                    results[regionKey][\"occupied\"] = 0;\n                }\n\n                prevIndex = results[regionKey][\"id\"].indexOf(previousDataIds[j]);\n                if (prevIndex === -1) {\n                    let keyList = Object.keys(previous_data[regionKey]);\n                    for (let k = 0; k < keyList.length; k++) {\n                        if (keyList[k] == \"video_id\" || keyList[k] == \"region_id\" || keyList[k] == \"occupied\") {\n                            continue;\n                        }\n                        results[regionKey][keyList[k]].push(previous_data[regionKey][keyList[k]][j]);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction handleOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n    if (previous_data[regionKey][\"entry_time\"] == \"\") {\n        results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n        results[regionKey][\"entry_time\"] = msg.object_timestamp;\n    }\n    else {\n        if (previous_data[regionKey][\"occupancy_check\"] >= occupancy_check_duration) {\n            results[regionKey][\"actual_dwell_time\"] = \"00:00:00\";\n            results[regionKey][\"dwell_time\"] = 0;\n            results[regionKey][\"actual_entry_time\"] = msg.nodered_timestamp;\n            results[regionKey][\"entry_time\"] = msg.object_timestamp;\n        }\n        else {\n            results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n            results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n        }\n\n        var dwell_timestamp = msg.object_timestamp - results[regionKey][\"entry_time\"];\n        var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n        dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, \"0\") : dwell_hours.toString();\n        var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, \"0\");\n        var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, \"0\");\n\n        results[regionKey][\"dwell_time\"] = dwell_timestamp;\n        results[regionKey][\"actual_dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n        results[regionKey][\"occupancy_check\"] = 0;\n    }\n\n    return results;\n}\n\nfunction handleNotOccupiedRegion(results, i) {\n    const regionKey = \"Region \" + (i + 1);\n\n    results[regionKey][\"actual_entry_time\"] = previous_data[regionKey][\"actual_entry_time\"];\n    results[regionKey][\"entry_time\"] = previous_data[regionKey][\"entry_time\"];\n    results[regionKey][\"actual_dwell_time\"] = previous_data[regionKey][\"actual_dwell_time\"];\n    results[regionKey][\"dwell_time\"] = previous_data[regionKey][\"dwell_time\"];\n    results[regionKey][\"occupancy_check\"] = previous_data[regionKey][\"occupancy_check\"] + 1;\n\n    if (previous_data[regionKey][\"exit_time\"]) {\n        results[regionKey][\"exit_time\"] = previous_data[regionKey][\"exit_time\"];\n    }\n    else {\n        results[regionKey][\"exit_time\"] = msg.nodered_timestamp;\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, intersection_type = \"region\", intersection_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, intersection_type, intersection_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get(\"distance_threshold\");\nvar intersection_type = flow.get(\"intersection_type\");\nvar intersection_threshold = flow.get(\"intersection_threshold\");\nvar object_counter = flow.get(\"object_counter\");\n\nmsg.payload = main(payload, distance_threshold, intersection_type, intersection_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;"},
            outputs: {value:1},
            timeout:{value:RED.settings.functionTimeout || 0},
            noerr: {value:0,required:true,
                    validate: function(v, opt) {
                        if (!v) {
                            return true;
                        }
                        return RED._("node-red:function.error.invalid-js");
                    }},
            initialize: {value:""},
            finalize: {value:""},
            libs: {value: [], validate: function(v, opt) {
                if (!v) { return true; }
                for (var i=0,l=v.length;i<l;i++) {
                    var m = v[i];
                    if (!RED.utils.checkModuleAllowed(m.module,null,installAllowList,installDenyList)) {
                        return RED._("node-red:function.error.moduleNotAllowed", {
                            module: m.module
                        });
                    }
                    if (m.var === "" || / /.test(m.var)) {
                        return RED._("node-red:function.error.moduleNameError", {
                            name: m.var
                        });
                    }
                    if (missingModules.indexOf(m.module) > -1) {
                        return RED._("node-red:function.error.missing-module", {
                            module: m.module
                        });
                    }
                    if (invalidModuleVNames.indexOf(m.var) !== -1){
                        return RED._("node-red:function.error.moduleNameError", {
                            name: m.var
                        });
                    }
                }
                return true;
            }}
        },
        inputs:1,
        outputs:1,
        icon: "function.svg",
        label: function() {
            return this.name||this._("function.function");
        },
        labelStyle: function() {
            return this.name?"node_label_italic":"";
        },
        oneditprepare: function() {
            var that = this;

            var tabs = RED.tabs.create({
                id: "func-tabs",
                onchange: function(tab) {
                    $("#func-tabs-content").children().hide();
                    $("#" + tab.id).show();
                    let editor = $("#" + tab.id).find('.monaco-editor').first();
                    if(editor.length) {
                        if(that.editor.nodered && that.editor.type == "monaco") {
                            that.editor.nodered.refreshModuleLibs(getLibsList());
                        }
                        RED.tray.resize();
                        //auto focus editor on tab switch
                        if (that.initEditor.getDomNode() == editor[0]) {
                            that.initEditor.focus();
                        } else if (that.editor.getDomNode() == editor[0]) {
                            that.editor.focus();
                        } else if (that.finalizeEditor.getDomNode() == editor[0]) {
                            that.finalizeEditor.focus();
                        }
                    }
                }
            });
            tabs.addTab({
                id: "func-tab-config",
                iconClass: "fa fa-cog",
                label: that._("function.label.setup")
            });

            tabs.addTab({
                id: "func-tab-init",
                label: that._("function.label.initialize")
            });
            tabs.addTab({
                id: "func-tab-body",
                label: that._("function.label.function")
            });
            tabs.addTab({
                id: "func-tab-finalize",
                label: that._("function.label.finalize")
            });

            tabs.activateTab("func-tab-body");

            $( "#node-input-outputs" ).spinner({
                min: 0,
                max: 500,
                change: function(event, ui) {
                    var value = parseInt(this.value);
                    value = isNaN(value) ? 1 : value;
                    value = Math.max(value, parseInt($(this).attr("aria-valuemin")));
                    value = Math.min(value, parseInt($(this).attr("aria-valuemax")));
                    if (value !== this.value) { $(this).spinner("value", value); }
                }
            });

            // 4294967 is max in node.js timeout.
            $( "#node-input-timeout" ).spinner({
                min: 0,
                max: 4294967,
                change: function(event, ui) {
                    var value = this.value;
                    if(value == ""){
                        value = 0;
                    }
                    else
                    {
                        value = parseInt(value);
                    }
                    value = isNaN(value) ? 1 : value;
                    value = Math.max(value, parseInt($(this).attr("aria-valuemin")));
                    value = Math.min(value, parseInt($(this).attr("aria-valuemax")));
                    if (value !== this.value) { $(this).spinner("value", value); }
                }
            });

            var buildEditor = function(id, stateId, focus, value, defaultValue, extraLibs, offset) {
                var editor = RED.editor.createEditor({
                    id: id,
                    mode: 'ace/mode/nrjavascript',
                    value: value || defaultValue || "",
                    stateId: stateId,
                    focus: true,
                    globals: {
                        msg:true,
                        context:true,
                        RED: true,
                        util: true,
                        flow: true,
                        global: true,
                        console: true,
                        Buffer: true,
                        setTimeout: true,
                        clearTimeout: true,
                        setInterval: true,
                        clearInterval: true
                    },
                    extraLibs: extraLibs
                });
                if (defaultValue && value === "") {
                    editor.moveCursorTo(defaultValue.split("\n").length +offset, 0);
                }
                editor.__stateId = stateId;
                return editor;
            }
            this.initEditor = buildEditor('node-input-init-editor', this.id + "/" + "initEditor", false, $("#node-input-initialize").val(), RED._("node-red:function.text.initialize"), undefined, 0);
            this.editor = buildEditor('node-input-func-editor', this.id + "/" + "editor", true, $("#node-input-func").val(), undefined, that.libs || [], undefined, -1);
            this.finalizeEditor = buildEditor('node-input-finalize-editor', this.id + "/" + "finalizeEditor", false, $("#node-input-finalize").val(), RED._("node-red:function.text.finalize"), undefined, 0);

            RED.library.create({
                url:"functions", // where to get the data from
                type:"function", // the type of object the library is for
                editor:this.editor, // the field name the main text body goes to
                mode:"ace/mode/nrjavascript",
                fields:[
                    'name', 'outputs', 'timeout',
                    {
                        name: 'initialize',
                        get: function() {
                            return that.initEditor.getValue();
                        },
                        set: function(v) {
                            that.initEditor.setValue(v||RED._("node-red:function.text.initialize"), -1);
                        }
                    },
                    {
                        name: 'finalize',
                        get: function() {
                            return that.finalizeEditor.getValue();
                        },
                        set: function(v) {
                            that.finalizeEditor.setValue(v||RED._("node-red:function.text.finalize"), -1);
                        }
                    },
                    {
                        name: 'info',
                        get: function() {
                            return that.infoEditor.getValue();
                        },
                        set: function(v) {
                            that.infoEditor.setValue(v||"", -1);
                        }
                    }
                ],
                ext:"js"
            });

            var expandButtonClickHandler = function(editor) {
                return function (e) {
                    e.preventDefault();
                    var value = editor.getValue();
                    editor.saveView(`inside function-expandButtonClickHandler ${editor.__stateId}`);
                    var extraLibs = that.libs || [];
                    RED.editor.editJavaScript({
                        value: value,
                        width: "Infinity",
                        stateId: editor.__stateId,
                        mode: "ace/mode/nrjavascript",
                        focus: true,
                        cancel: function () {
                            setTimeout(function () {
                                editor.focus();
                            }, 250);
                        },
                        complete: function (v, cursor) {
                            editor.setValue(v, -1);
                            setTimeout(function () {
                                editor.restoreView();
                                editor.focus();
                            }, 250);
                        },
                        extraLibs: extraLibs
                    });
                }
            }
            $("#node-init-expand-js").on("click", expandButtonClickHandler(this.initEditor));
            $("#node-function-expand-js").on("click", expandButtonClickHandler(this.editor));
            $("#node-finalize-expand-js").on("click", expandButtonClickHandler(this.finalizeEditor));

            RED.popover.tooltip($("#node-init-expand-js"), RED._("node-red:common.label.expand"));
            RED.popover.tooltip($("#node-function-expand-js"), RED._("node-red:common.label.expand"));
            RED.popover.tooltip($("#node-finalize-expand-js"), RED._("node-red:common.label.expand"));

            if (RED.settings.functionExternalModules !== false) {
                prepareLibraryConfig(that);
            }
        },
        oneditsave: function() {
            var node = this;
            var noerr = 0;
            $("#node-input-noerr").val(0);

            var disposeEditor = function(editorName,targetName,defaultValue) {
                var editor = node[editorName];
                var annot = editor.getSession().getAnnotations();
                for (var k=0; k < annot.length; k++) {
                    if (annot[k].type === "error") {
                        noerr += annot.length;
                        break;
                    }
                }
                var val = editor.getValue();
                if (defaultValue) {
                    if (val.trim() == defaultValue.trim()) {
                        val = "";
                    }
                }
                editor.destroy();
                delete node[editorName];
                $("#"+targetName).val(val);
            }
            disposeEditor("editor","node-input-func");
            disposeEditor("initEditor","node-input-initialize", RED._("node-red:function.text.initialize"));
            disposeEditor("finalizeEditor","node-input-finalize", RED._("node-red:function.text.finalize"));

            $("#node-input-noerr").val(noerr);
            this.noerr = noerr;
            node.libs = getLibsList();
        },
        oneditcancel: function() {
            var node = this;

            node.editor.destroy();
            delete node.editor;

            node.initEditor.destroy();
            delete node.initEditor;

            node.finalizeEditor.destroy();
            delete node.finalizeEditor;
        },
        oneditresize: function(size) {
            var rows = $("#dialog-form>div:not(.node-text-editor-row)");
            var height = $("#dialog-form").height();
            for (var i=0; i<rows.length; i++) {
                height -= $(rows[i]).outerHeight(true);
            }
            var editorRow = $("#dialog-form>div.node-text-editor-row");
            height -= (parseInt(editorRow.css("marginTop"))+parseInt(editorRow.css("marginBottom")));
            $("#dialog-form .node-text-editor").css("height",height+"px");

            var height = size.height;
            $("#node-input-init-editor").css("height", (height - 83)+"px");
            $("#node-input-func-editor").css("height", (height - 83)+"px");
            $("#node-input-finalize-editor").css("height", (height - 83)+"px");

            this.initEditor.resize();
            this.editor.resize();
            this.finalizeEditor.resize();

            $("#node-input-libs-container").css("height", (height - 192)+"px");
        },
        onadd: function() {
            if (this.name === '_DEFAULT_') {
                this.name = ''
                RED.actions.invoke("core:generate-node-names", this, {generateHistory: false})
            }
        }
    });
})();
</script>
